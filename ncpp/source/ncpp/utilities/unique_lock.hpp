#pragma once

/**
 *  @file ncpp/utilities/unique_lock.hpp
 *  @brief Implements unique_lock_t.
 */



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Includes

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/prerequisites.hpp>

#pragma endregion



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {

    namespace utilities {

        namespace internal {

            template<class F__>
            concept T_is_has_read_lock_unlock = requires (F__ lock) {

                lock.rlock();
                lock.runlock();

            };

            template<class F__>
            concept T_is_has_write_lock_unlock = requires (F__ lock) {

                lock.wlock();
                lock.wunlock();

            };

            template<class F__>
            concept T_is_has_normal_lock_unlock = requires (F__ lock) {

                lock.lock();
                lock.unlock();

            };



            template<b8 is_has_read_lock_unlock__, typename F__>
            struct TF_rlock_runlock_helper;

            template<typename F__>
            struct TF_rlock_runlock_helper<true, F__> {

                static NCPP_FORCE_INLINE void lock(F__& locker) {

                    locker.rlock();

                }

                static NCPP_FORCE_INLINE void unlock(F__& locker) {

                    locker.runlock();

                }

            };

            template<typename F__>
            struct TF_rlock_runlock_helper<false, F__> {

                static NCPP_FORCE_INLINE void lock(F__& locker) {

                    locker.lock();

                }

                static NCPP_FORCE_INLINE void unlock(F__& locker) {

                    locker.unlock();

                }

            };



            template<b8 is_has_write_lock_unlock__, typename F__>
            struct TF_wlock_wunlock_helper;

            template<typename F__>
            struct TF_wlock_wunlock_helper<true, F__> {

                static NCPP_FORCE_INLINE void lock(F__& locker) {

                    locker.wlock();

                }

                static NCPP_FORCE_INLINE void unlock(F__& locker) {

                    locker.wunlock();

                }

            };

            template<typename F__>
            struct TF_wlock_wunlock_helper<false, F__> {

                static NCPP_FORCE_INLINE void lock(F__& locker) {

                    locker.lock();

                }

                static NCPP_FORCE_INLINE void unlock(F__& locker) {

                    locker.unlock();

                }

            };

        }



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        enum class E_unique_lock_access {

            READ_WRITE = 0x3,
            READ_ONLY = 0x1,
            WRITE_ONLY = 0x2

        };



        /**
         *  An object that manages a mutex object by keeping it always locked.
         *  @param <locker_class__>
         */
        template<class F_locker__, E_unique_lock_access access__ = E_unique_lock_access::READ_WRITE>
        class TF_unique_lock {

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

        public:
            using F_locker = F_locker__;

            static constexpr E_unique_lock_access access = access__;

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

            NCPP_STATIC_ASSERT(
                !(access == E_unique_lock_access::READ_ONLY)
                || (
                    (access == E_unique_lock_access::READ_ONLY)
                    && (
                        internal::T_is_has_read_lock_unlock<F_locker>
                        || internal::T_is_has_normal_lock_unlock<F_locker>
                    )
                ),
                "invalid read-only lock"
            );
            NCPP_STATIC_ASSERT(
                !(access == E_unique_lock_access::WRITE_ONLY)
                || (
                    (access == E_unique_lock_access::WRITE_ONLY)
                    && (
                        internal::T_is_has_write_lock_unlock<F_locker>
                        || internal::T_is_has_normal_lock_unlock<F_locker>
                    )
                ),
                "invalid write-only lock"
            );

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

        private:
            F_locker__& locker_;

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

        public:
            NCPP_FORCE_INLINE F_locker__& locker() { return locker_; }
            NCPP_FORCE_INLINE const F_locker__& locker() const { return locker_; }

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

        public:
            NCPP_FORCE_INLINE TF_unique_lock(F_locker__& locker) :
                locker_(locker)
            {

                if constexpr (access == E_unique_lock_access::READ_ONLY)
                    internal::TF_rlock_runlock_helper<
                        internal::T_is_has_read_lock_unlock<F_locker__>,
                        F_locker__
                    >::lock(locker);
                else if constexpr (access == E_unique_lock_access::WRITE_ONLY)
                    internal::TF_wlock_wunlock_helper<
                        internal::T_is_has_write_lock_unlock<F_locker__>,
                        F_locker__
                    >::lock(locker);
                else
                    locker_.lock();

            }
            ~TF_unique_lock() {

                if constexpr (access == E_unique_lock_access::READ_ONLY)
                    internal::TF_rlock_runlock_helper<
                        internal::T_is_has_read_lock_unlock<F_locker__>,
                        F_locker__
                    >::unlock(locker_);
                else if constexpr (access == E_unique_lock_access::WRITE_ONLY)
                    internal::TF_wlock_wunlock_helper<
                        internal::T_is_has_write_lock_unlock<F_locker__>,
                        F_locker__
                    >::unlock(locker_);
                else
                    locker_.unlock();

            }

        };

    }

}



#define NCPP_SCOPED_LOCK(...) ncpp::utilities::TF_unique_lock<decltype(__VA_ARGS__)> NCPP_GLUE(___ncpp_scoped_lock___, __LINE__)(__VA_ARGS__);
#define NCPP_SCOPED_LOCK_READ_ONLY(...) ncpp::utilities::TF_unique_lock<decltype(__VA_ARGS__), ncpp::utilities::E_unique_lock_access::READ_ONLY> NCPP_GLUE(___ncpp_scoped_lock___, __LINE__)(__VA_ARGS__);
#define NCPP_SCOPED_LOCK_WRITE_ONLY(...) ncpp::utilities::TF_unique_lock<decltype(__VA_ARGS__), ncpp::utilities::E_unique_lock_access::WRITE_ONLY> NCPP_GLUE(___ncpp_scoped_lock___, __LINE__)(__VA_ARGS__);